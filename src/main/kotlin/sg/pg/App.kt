/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package sg.pg

import org.postgresql.PGConnection
import org.postgresql.PGProperty
import org.postgresql.core.BaseConnection
import org.postgresql.core.ServerVersion
import org.postgresql.replication.LogSequenceNumber
import java.nio.ByteBuffer
import java.sql.Connection
import java.sql.DriverManager
import java.sql.SQLException
import java.util.*
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException


//class App {
//    val greeting: String
//        get() {
//            return "Hello world."
//        }
//}

//fun main(args: Array<String>) {
////    println(App().greeting)
//}

class App {

    lateinit var connection: Connection
    lateinit var replicationConnection: Connection

    private val currentLSN: LogSequenceNumber
        @Throws(SQLException::class)
        get() {
            connection.createStatement().use({ st ->
                st.executeQuery("select " + if ((connection as BaseConnection).haveMinimumServerVersion(ServerVersion.v10))
                    "pg_current_wal_lsn()"
                else
                    "pg_current_xlog_location()").use({ rs ->

                    if (rs.next()) {
                        val lsn = rs.getString(1)
                        return LogSequenceNumber.valueOf(lsn)
                    } else {
                        return LogSequenceNumber.INVALID_LSN
                    }
                })
            })
        }
    private val isServerCompatible: Boolean
        get() = (connection as BaseConnection).haveMinimumServerVersion(ServerVersion.v9_5)

    private fun createUrl(): String {
        return "jdbc:postgresql://$HOST:$PORT/$DATABASE"
    }

    fun createConnection() {
        try {
            connection = DriverManager.getConnection(createUrl(), "postgres", "pw")
        } catch (ex: SQLException) {
            print(ex)
        }

    }

    @Throws(SQLException::class)
    fun dropPublication(publication: String) {

        connection.prepareStatement("DROP PUBLICATION $publication").use({ preparedStatement -> preparedStatement.execute() })
    }

    @Throws(SQLException::class)
    fun createPublication(publication: String) {

        connection.prepareStatement("CREATE PUBLICATION $publication FOR ALL TABLES").use({ preparedStatement -> preparedStatement.execute() })
    }


    @Throws(InterruptedException::class, SQLException::class, TimeoutException::class)
    fun createLogicalReplicationSlot(slotName: String, outputPlugin: String) {
        //drop previous slot
        dropReplicationSlot(connection, slotName)

        connection.prepareStatement("SELECT * FROM pg_create_logical_replication_slot(?, ?)").use({ preparedStatement ->
            preparedStatement.setString(1, slotName)
            preparedStatement.setString(2, outputPlugin)
            preparedStatement.executeQuery().use({ rs ->
                while (rs.next()) {
                    println("Slot Name: " + rs.getString(1))
                    println("Xlog Position: " + rs.getString(2))
                }
            })

        })
    }

    @Throws(SQLException::class, InterruptedException::class, TimeoutException::class)
    fun dropReplicationSlot(connection: Connection, slotName: String) {
        connection.prepareStatement(
                "select pg_terminate_backend(active_pid) from pg_replication_slots " + "where active = true and slot_name = ?").use({ preparedStatement ->
            preparedStatement.setString(1, slotName)
            preparedStatement.execute()
        })

        waitStopReplicationSlot(connection, slotName)

        connection.prepareStatement("select pg_drop_replication_slot(slot_name) " + "from pg_replication_slots where slot_name = ?").use({ preparedStatement ->
            preparedStatement.setString(1, slotName)
            preparedStatement.execute()
        })
    }

    @Throws(SQLException::class)
    fun isReplicationSlotActive(connection: Connection, slotName: String): Boolean {

        connection.prepareStatement("select active from pg_replication_slots where slot_name = ?").use({ preparedStatement ->
            preparedStatement.setString(1, slotName)
            preparedStatement.executeQuery().use({ rs -> return rs.next() && rs.getBoolean(1) })
        })
    }

    @Throws(InterruptedException::class, TimeoutException::class, SQLException::class)
    private fun waitStopReplicationSlot(connection: Connection, slotName: String) {
        val startWaitTime = System.currentTimeMillis()
        var stillActive: Boolean
        var timeInWait: Long = 0

        do {
            stillActive = isReplicationSlotActive(connection, slotName)
            if (stillActive) {
                TimeUnit.MILLISECONDS.sleep(100L)
                timeInWait = System.currentTimeMillis() - startWaitTime
            }
        } while (stillActive && timeInWait <= 30000)

        if (stillActive) {
            throw TimeoutException("Wait stop replication slot $timeInWait timeout occurs")
        }
    }

    @Throws(Exception::class)
    fun receiveChangesOccursBeforStartReplication() {
        val pgConnection = replicationConnection as PGConnection

//        val lsn = currentLSN
//        println("lsn ${lsn.asLong()}")

//        val st = connection.createStatement()
//        st.execute("insert into test_logical_table(name) values('previous value')")
//        st.execute("insert into test_logical_table(name) values('previous value')")
//        st.execute("insert into test_logical_table(name) values('previous value')")
//        st.close()

        val stream = pgConnection
                .replicationAPI
                .replicationStream()
                .logical()
                .withSlotName(SLOT_NAME)

//                .withStartPosition(lsn)

                //    .withSlotOption("proto_version",1)
                //    .withSlotOption("publication_names", "pub1")
                .withSlotOption("pretty-print", false)
                .withSlotOption("include-xids", true)
                //    .withSlotOption("skip-empty-xacts", true)
                .withStatusInterval(10, TimeUnit.SECONDS)
                .start()

        var buffer: ByteBuffer?
        while (true) {
            buffer = stream.readPending()
            if (buffer == null) {
                TimeUnit.MILLISECONDS.sleep(10L)
                continue
            }

            println(toString(buffer!!))
            //feedback
            stream.setAppliedLSN(stream.lastReceiveLSN)
            stream.setFlushedLSN(stream.lastReceiveLSN)
        }

    }

    @Throws(Exception::class)
    private fun openReplicationConnection() {
        val properties = Properties()
        properties.setProperty("user", "postgres")
        properties.setProperty("password", "pw")
        PGProperty.ASSUME_MIN_SERVER_VERSION.set(properties, "9.4")
        PGProperty.REPLICATION.set(properties, "database")
        PGProperty.PREFER_QUERY_MODE.set(properties, "simple")
        replicationConnection = DriverManager.getConnection(createUrl(), properties)
    }

    companion object {
        private val SLOT_NAME = "slot"
        private val HOST = "localhost"
        private val PORT = "5432"
        private val DATABASE = "test"


        private fun toString(buffer: ByteBuffer): String {
            val offset = buffer.arrayOffset()
            val source = buffer.array()
            val length = source.size - offset

            return String(source, offset, length)
        }

        @JvmStatic
        fun main(args: Array<String>) {
            val pluginName = "wal2json"

            val app = App()
            app.createConnection()
//            if (!app.isServerCompatible) {
//                System.err.println("must have server version greater than 9.4")
//                System.exit(-1)
//            }
            try {
//                app.createLogicalReplicationSlot(SLOT_NAME, pluginName)
//                            app.dropPublication("pub1");
                //            app.createPublication("pub1");
                app.openReplicationConnection()
                app.receiveChangesOccursBeforStartReplication()
            } catch (e: InterruptedException) {
                e.printStackTrace()
            } catch (e: SQLException) {
                e.printStackTrace()
            } catch (e: TimeoutException) {
                e.printStackTrace()
            } catch (e: Exception) {
                e.printStackTrace()
            }

        }
    }
}